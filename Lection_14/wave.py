# def wave(maze, start, wall_cell):
#     """ функція побудови хвильової матриці
#     :param maze: Матриця лабіринту
#     :param start: Початкова точка лабіринту
#     :param wall_cell: символ, позначає стіну або непрохідну клітину
#     :return: хвильову матрицю та sources-матрицю
#     """
#
#     di = [-1, 0, 1, 0]
#     dj = [0, -1, 0, 1]
#
#     # di = [-1, -1, 0, 1, 1, 1, 0, -1]
#     # dj = [0, -1, -1, -1, 0, 1, 1, 1]
#
#     n = len(maze)  # кількість рядків у матриці maze
#     m = len(maze[0])  # кількість стовпчиків у матриці maze
#
#     ...
#
#     # створення та ініціалізація хвильової матриці
#     # такої ж розмірності, що і матриця лабіринту
#     waveMatrix = []
#     for i in range(n):
#         row = [-1] * m
#     waveMatrix.append(row)
#
#     # створення та ініціалізація sources-матриці
#     # такої ж розмірності, що і матриця лабіринту
#     sources = []
#     for i in range(n):
#         row = [None] * m
#     sources.append(row)
#
#     ...
#
#     q = Queue()  # Створюємо чергу
#     q.enqueue(start)  # Додаємо у чергу координати стартової клітини
#     waveMatrix[start[0]][start[1]] = 0  # Відстань від до стартової 0
#
#     while not q.empty():
#
#     current = q.dequeue()  # Беремо перший елемент з черги
#     i = current[0]  # координата поточного рядка матриці
#     j = current[1]  # координата поточного стовпчика матриці
#
#     # Додаємо в чергу всі сусідні клітини
#     for k in range(len(di)):
#         i1 = i + di[k]  # координата рядка сусідньої клітини
#     j1 = j + dj[k]  # координата стовпчика сусідньої клітини
#
#     # які ще не були відвідані та у які можна пересуватися
#     if waveMatrix[i1][j1] == -1 and maze[i1][j1] != wall_cell:
#
#     q.enqueue((i1, j1))
#
#     # Встановлюємо відстань на одиницю більшу ніж для поточної
#     waveMatrix[i1][j1] = waveMatrix[i][j] + 1
#     # Встановлюємо координати звідки ми прийшли у клітину
#     sources[i1][j1] = (i, j)
#
#     # Повертаємо хвильову матрицю, та sources-матрицю
#     return waveMatrix, sources